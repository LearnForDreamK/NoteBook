

[TOC]

## ZooKeeper基本概念总结

### 引用

> ZAB协议
> https://dbaplus.cn/news-141-1875-1.html
> Zookeeper入门
> https://juejin.cn/post/6844903677367418893
> 分布式锁
> https://mp.weixin.qq.com/s/ZqQHWLfVD1Rz1agmH3LWrg
> https://juejin.cn/post/6844903881776824333
> 结点信息
> https://www.cnblogs.com/dream-to-pku/p/9513188.html
> 数据一致性
> https://www.cnblogs.com/zz-ksw/p/12786067.html

### 1.特性

1.分布式程序，高可用。
2.数据在内存，高吞吐。
3.读多写少情况性能高，写会让所有服务器同步状态（读比写多是协调服务的主要场景）。

### 2.特点

1.顺序一致性，同一客户端事务请求严格按顺序执行。
2.原子性，所有事务请求处理在所有机器的应用情况一致。（分布式事务）
3.单一系统映像，无论客户端连接到哪一个zk服务器，看到的数据模型相同。
4.可靠性，一旦一次更改请求被应用，更改结果会被持久化。

主要提供两个功能
1.管理用户程序提交的数据。
2.为用户程序提交数据节点监听服务。

### 3.基本概念

#### 1.会话

一个客户端和服务器建立TCP连接。
通过心跳保持有效会话。
通过连接接收服务器的watch事件通知。
sessionTimeout属性可以设置超时时间，规定时间内会话被保存。

#### 2.Znode

所有数据以树的形式存储在内存,节点可以指机器，也可以指数据节点，比如

> /foo/path1 表示一个数据节点,保存数据信息+属性信息

节点分为两种，持久节点和临时节点。
持久节点ZNode一旦被创建，除非主动移除，否则会一直保存在zk里，临时节点的生命周期和客户端会话绑定，会话失效所有绑定的临时节点会被移除。 ZK允许用户给每个节点添加一个特殊属性SEQUENTIAL，节点在创建后节点名后会追加一个父节点维护的自增数字。
还有一个维度的结点是Sequence	vs.	Non-sequence结点
Non-sequence：多个客户端只有一个客户端可以创建成功，理解为Leader结点。
Sequence：创建出的结点名在指定名称后+10位10进制的序号。

#### 3.版本

ZK为每个ZNode维护一个Stat数据结构，记录Znode的当前版本，子节点版本，历史版本。(version、cversion、ACL)

#### 4.Watcher（监听器）

ZK允许用户在指定节点注册watcher，在特定事件触发时，服务端会把事件通知到感兴趣的客户端，此机制是zk实现分布式协调服务的重要特性。

#### 5.ACL（AccessControlLists）

ZK使用ACL策略进行权限控制。CREATE和DELETE都是针对子节点的控制。

> CREATE：创建子节点权限
> READ：获取节点数据和子节点列表的权限
> WRITE：更新节点数据的权限
> DELETE：删除子节点权限
> ADMIN：设置节点ACL权限

#### 6.设计目标

允许分布式进程通过共享的层次结构命名空间相互协调，名称空间即znode，实现高吞吐量和低延迟。

```java
					Node1(  / )
		Node2( /app1 )	Node3( /app2)
Node3( /app1/p_1)
```

### 4.集群使用

为保证高可用，最好以集群来部署ZK。客户端使用时，通过和某一台机器建立TCP连接来使用服务（发请求、获取监听事件、发送心跳），如果当前连接断开，客户端可以连接到其他机器上。
组成ZK服务的服务器都会在内存中维护当前服务器状态，并且每台服务器之间都保持通信，集群间通过Zab(Zookeeper Atomic Broadcast)协议保持数据一致性。

##### 1.顺序访问

对于客户端每个更新请求，ZK会分配一个全局唯一的递增编号，这个编号可以反应所有事务操作的先后顺序（应用程序可以以此实现高层次的同步），这个编号也叫时间戳——zxid(Zookeeper Transaction Id)

##### 2.集群角色

ZK集群主要有三种成员，Leader、Observer、Follower 。Leader可以读写，后两者只能读，相比于Follower，oberber不参与过半写成功策略，也不参与Leader选举。

##### 3.ZAB协议

包含两种模式，崩溃恢复和消息广播。 服务启动时，或Leader服务器挂了（网络中断、崩溃、重启等）,ZAB协议会让系统进入恢复模式并选举产生新服务器，当有过半服务器和leader完成状态同步（数据保证一致）后，ZAB协议会让系统退出恢复模式。当有过半Follow服务器完成同步后，服务就可以进入消息广播模式。新加入的遵守ZAB协议的服务器会自觉进入恢复模式找到leader服务器并进行数据同步，然后一起参与消息广播。如果普通服务器收到客户端事务请求，会首先把事务请求转发给leader服务器。

##### 4.基于TCP的**FastLeaderElection**算法

myid：每个ZK服务器数据文件夹下包含一个名为myid的文件，包含整个ZK集群的唯一Id。
zxid：高32位是Leader的epoch，每次选举新的leader，epoch+1，每次epoch变化，都会把低32位的序号重置。保证zxid全局递增唯一。

每个服务器在进行领导选举时，会发送如下关键信息：

- **logicClock** 每个服务器会维护一个自增的整数，名为logicClock，它表示这是该服务器发起的第多少轮投票
- **state** 当前服务器的状态
- **self_id** 当前服务器的myid
- **self_zxid** 当前服务器上所保存的数据的最大zxid
- **vote_id** 被推举的服务器的myid
- **vote_zxid** 被推举的服务器上所保存的数据的最大zxid

###### 比较规则

先比较logicClock，如果自己的比收到的投票的logicClock小，先更新自己的logicClock为最大的。
logicClock相等时，进行选票PK，先比较vote_zxid大小，如果别人的大，更新自己的选票为他人的最大的（vote_zxid），清空票箱，把自己选票和当前选票存入自己票箱，进行广播。
如果vote_zxid相等，则比较myid，myid是每台服务器唯一的，比较会以myid为基准。
例子1：集群启动
有三台服务器的集群启动，myid分别为1,2,3。
1）每个服务器先给自己投票（1，1，0）、（1，2，0）、（1，3，0）,第一个代表logicClock，第二个代表服务器myid，第三个代表zxid。
2）每台服务器收到外界的两张票，因为logicClock都相等，所以都进行选票PK，因为vote_zxid都相等，所以比较myid，myid为1的服务器把自己选票更新为（1，3），丢弃
myid为2的选票，留下两张票（1,3）（3,3），myid为2的服务器同理留下(2,3) (3,3)，myid为3的服务器只需要保留自己的票，不需要更新，然后广播，三台服务器票箱相同，都是让myid3的服务器为leader，投票结束。

如果某台follower因为网络或其他原因重启找不到leader，上线后会重新发起选举流程，leader和follower收到广播消息后会返回投票信息和当前服务器状态信息（是什么角色），重连的follower根据返回的ack确认原来的leader，并成为follower状态。

leader挂了，选举数据最新的服务器为leader，同步数据，对外提供服务。

commit的数据在重新选举后新leader通过TRUNC命令同步到follower结点和observer结点。 每台follower会把自己提交的zxid和未提交的zxid_set集合发送给leader，当某一数据在过半服务器上收到请求，但都未提交，新leader会提交该事务然后使用TRUNC同步，少于过半则leader发送命令让follower删除未提交的数据。

##### 5.watch机制

所有对 ZooKeeper 的读操作，都可附带一个 Watch 。一旦相应的数据有变化，该 Watch 即被触发。

1.主动推送
2.一次性（watch只会被触发一次，需要后续更新只要重新注册watch）
3.可见性。（更新通知先于更新结果）
4.顺序性（watch被触发的顺序和更新顺序一致）。

##### 6.非公平领导选举

多个客户端同时向集群注册Ephemeral类型的non-sequence类型的结点，只有一个客户端能成功注册为leader，其他客户端此时变为follower。
如果leader挂了，zk和客户端的session即会结束，因为是非持久结点，所以结点会被自动删除，又或者leader主动放弃主导权，即删除/zkroot/leader结点。
**感知领导权**
创建结点失败的结点除了成为follower还会向/zkroot/leader注册一个watch，一旦Leader放弃领导权，改节点被删除，所有的follower都会收到通知。
**重新选举**
和最初选举一样，发起结点创建请求，创建成功就成为Leader，否则为follower。

##### 8.公平领导选举

所有客户端均创建sequence类型结点成功，只是序号不同，每个客户端判断自己创建的结点序号是不是最小的，如果是则改客户端为leader，否则为follower。
和非公平模式不同，每个follower都是watch序号刚好比自己小的结点。如果leader挂了，watch leader的那个结点会先判断自己的序号是不是最小，如果是最小则直接成为leader，其他节点不会受影响。如果1<2<3 这种，2挂了，3会先判断自己是不是最小序号，如果不是则向挂了的结点序号前面序号的结点创建watch，这里即向1创建watch。



### 5.分布式锁

#### 方式1

通过创建节点来获得锁，很多个应用同时创建节点，只有一个节点能创建成功，没创建成功的节点阻塞自己（可以使用次数为1的栅栏锁），监听节点的删除操作，拿到锁的节点如果宕机了或者释放了锁，都会触发监听操作，监听器里释放栅栏锁，继续争抢锁。 缺点是有惊群效应，每次释放锁要通知所有其他节点争抢锁，开销很大。

#### 方式2

通过创建临时顺序节点获得锁，很多应用同时创建自己的节点，进行排序，数字最小的节点获得锁，每个节点监听自己前一个节点的移除事件。是一种公平锁，如果某一普通节点挂了，他的下一个节点因为监听器会尝试获取锁，没拿到就监听他的上一个节点。

